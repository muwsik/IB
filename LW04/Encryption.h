//#pragma once
//
//#include <iostream>
//#include <fstream>
//#include <vector>
//#include <string>
//
//struct block64
//{
//	uint64_t left;
//	uint64_t right;
//	void swap()
//	{
//		*this = { this->right, this->left };
//	}
//};
//
//
//
//class Encryption
//{
//
//public: uint64_t key[4] = { 0 };
//
//private: const uint64_t table[16][16] =
//{
//	{ 0x4,0xa,0x9,0x2,0xd,0x8,0x0,0xe,0x6,0xb,0x1,0xc,0x7,0xf,0x5,0x3 },
//	{ 0xe,0xb,0x4,0xc,0x6,0xd,0xf,0xa,0x2,0x3,0x8,0x1,0x0,0x7,0x5,0x9 },
//	{ 0x5,0x8,0x1,0xd,0xa,0x3,0x4,0x2,0xe,0xf,0xc,0x7,0x6,0x0,0x9,0xb },
//	{ 0x7,0xd,0xa,0x1,0x0,0x8,0x9,0xf,0xe,0x4,0x6,0xc,0xb,0x2,0x5,0x3 },
//	{ 0x6,0xc,0x7,0x1,0x5,0xf,0xd,0x8,0x4,0xa,0x9,0xe,0x0,0x3,0xb,0x2 },
//	{ 0x4,0xb,0xa,0x0,0x7,0x2,0x1,0xd,0x3,0x6,0x8,0x5,0x9,0xc,0xf,0xe },
//	{ 0xd,0xb,0x4,0x1,0x3,0xf,0x5,0x9,0x0,0xa,0xe,0x7,0x6,0x8,0x2,0xc },
//	{ 0x1,0xf,0xd,0x0,0x5,0x7,0xa,0x4,0x9,0x2,0x3,0xe,0x6,0xb,0x8,0xc },
//	{ 0x7,0xf,0xd,0x0,0x5,0x1,0xa,0x4,0x9,0x2,0x3,0xe,0x6,0xb,0x8,0xc },
//	{ 0x1,0xa,0xd,0x0,0xb,0x7,0xf,0x4,0x9,0x2,0x3,0xe,0x6,0x5,0x8,0xc },
//	{ 0x1,0xc,0xd,0x0,0x5,0x7,0xa,0x4,0x9,0x2,0x3,0xe,0x6,0xb,0x8,0xf },
//	{ 0x8,0xf,0xd,0x0,0x5,0x7,0xa,0x4,0x9,0x2,0x3,0xe,0x6,0xb,0x1,0xc },
//	{ 0x5,0xf,0x1,0xd,0xa,0x3,0x4,0x2,0xe,0x8,0xc,0x7,0x6,0x0,0x9,0xb },
//	{ 0x4,0x5,0x9,0x2,0xd,0x8,0x0,0xe,0x6,0xb,0x1,0xc,0x3,0xf,0xa,0x7 },
//	{ 0x4,0xa,0x9,0xf,0xd,0x8,0x0,0xe,0x6,0xb,0x1,0xc,0x7,0x2,0x5,0x3 },
//	{ 0x4,0xa,0x9,0x2,0xd,0x8,0x0,0xe,0x3,0xb,0x1,0xc,0x7,0x5,0xf,0x6 },
//};
//
//public: Encryption(std::string name)
//{
//	std::ifstream file(name, std::ios::binary);
//	for (size_t i = 0; i < 4; i++)
//	{
//		file.read((char*)&key[i], sizeof(uint64_t));
//	}
//}
//
//private: uint64_t ReplaceBlock(uint64_t x)
//{
//	struct uint_4bit
//	{
//		uint64_t bit4 : 4;
//	} part = { 0 };
//
//	uint64_t result = 0ULL;
//	for (int i = 15; i >= 0; i--)
//	{
//		part.bit4 = x >> (i * 4);
//		part.bit4 = table[i][part.bit4];
//		result = (result << 4) | part.bit4;
//	}
//	return uint64_t(result);
//}
//
//public:	block64 MainStep(block64 N, uint64_t x)
//{	//N1 -> младшая -> правая 
//	uint64_t S = 0ULL;
//	S = N.right + x % 0xffffffffffffffff;
//	S = ReplaceBlock(S);
//	S = (S << 11) | (S >> 53);
//	S ^= N.left;
//	return{ N.right, S };
//}
//
//public: ~Encryption()
//{	}
//
//};